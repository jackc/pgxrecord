package pgxrecord_test

import (
	"context"
	"os"
	"testing"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxtest"
	"github.com/jackc/pgxrecord"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

var defaultConnTestRunner pgxtest.ConnTestRunner

func init() {
	defaultConnTestRunner = pgxtest.DefaultConnTestRunner()
	defaultConnTestRunner.CreateConfig = func(ctx context.Context, t testing.TB) *pgx.ConnConfig {
		config, err := pgx.ParseConfig(os.Getenv("PGXRECORD_TEST_DATABASE"))
		require.NoError(t, err)
		return config
	}
}

func TestTableLoadAllColumns(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		table := &pgxrecord.Table{
			Name: pgx.Identifier{"t"},
		}
		err = table.LoadAllColumns(ctx, conn)
		require.NoError(t, err)
		table.Finalize()

		require.Len(t, table.Columns, 3)
		expectedColumns := []pgxrecord.Column{
			{Name: "id", OID: pgtype.Int4OID, NotNull: true, PrimaryKey: true},
			{Name: "name", OID: pgtype.TextOID, NotNull: true, PrimaryKey: false},
			{Name: "age", OID: pgtype.Int4OID, NotNull: false, PrimaryKey: false},
		}
		for i := range expectedColumns {
			assert.Equalf(t, expectedColumns[i].Name, table.Columns[i].Name, "Column %d name", i+1)
			assert.Equalf(t, expectedColumns[i].OID, table.Columns[i].OID, "Column %d OID", i+1)
			assert.Equalf(t, expectedColumns[i].NotNull, table.Columns[i].NotNull, "Column %d not null", i+1)
			assert.Equalf(t, expectedColumns[i].PrimaryKey, table.Columns[i].PrimaryKey, "Column %d primary key", i+1)
		}
	})
}

func TestTableSelectQuery(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		table := &pgxrecord.Table{
			Name: pgx.Identifier{"t"},
		}
		err = table.LoadAllColumns(ctx, conn)
		require.NoError(t, err)
		table.Finalize()

		require.Equal(t, `select "t"."id", "t"."name", "t"."age" from "t"`, table.SelectQuery())
	})
}

func TestTableNewRecord(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		table := &pgxrecord.Table{
			Name: pgx.Identifier{"t"},
		}
		err = table.LoadAllColumns(ctx, conn)
		require.NoError(t, err)
		table.Finalize()

		record := table.NewRecord()
		require.Equal(t, map[string]any{"id": nil, "name": nil, "age": nil}, record.Attributes())

		record.SetAttributes(map[string]any{"name": "John", "age": 42})
		require.Equal(t, map[string]any{"id": nil, "name": "John", "age": 42}, record.Attributes())
	})
}

func TestTableFindByPK(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		var id int32
		err = conn.QueryRow(ctx, `insert into t (name, age) values ('John', 42) returning id`).Scan(&id)
		require.NoError(t, err)

		table := &pgxrecord.Table{
			Name: pgx.Identifier{"t"},
		}
		err = table.LoadAllColumns(ctx, conn)
		require.NoError(t, err)
		table.Finalize()

		record, err := table.FindByPK(ctx, conn, id)
		require.NoError(t, err)
		require.Equal(t, map[string]any{"id": int32(1), "name": "John", "age": int32(42)}, record.Attributes())
	})
}

func TestRecordSetAndGet(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		table := &pgxrecord.Table{
			Name: pgx.Identifier{"t"},
		}
		err = table.LoadAllColumns(ctx, conn)
		require.NoError(t, err)
		table.Finalize()

		record := table.NewRecord()

		err = record.Set("name", "John")
		require.NoError(t, err)

		name, err := record.Get("name")
		require.NoError(t, err)
		require.Equal(t, "John", name)
	})
}

func TestRecordSaveInsert(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		table := &pgxrecord.Table{
			Name: pgx.Identifier{"t"},
		}
		err = table.LoadAllColumns(ctx, conn)
		require.NoError(t, err)
		table.Finalize()

		record := table.NewRecord()
		record.SetAttributes(map[string]any{"name": "John", "age": 42})
		err = record.Save(ctx, conn)
		require.NoError(t, err)

		require.Equal(t, map[string]any{"id": int32(1), "name": "John", "age": int32(42)}, record.Attributes())
	})
}

func TestRecordSaveUpdate(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		var id int32
		err = conn.QueryRow(ctx, `insert into t (name, age) values ('John', 42) returning id`).Scan(&id)
		require.NoError(t, err)

		table := &pgxrecord.Table{
			Name: pgx.Identifier{"t"},
		}
		err = table.LoadAllColumns(ctx, conn)
		require.NoError(t, err)
		table.Finalize()

		record, err := table.FindByPK(ctx, conn, id)
		require.NoError(t, err)
		require.Equal(t, map[string]any{"id": int32(1), "name": "John", "age": int32(42)}, record.Attributes())

		record.MustSet("name", "Bill")
		err = record.Save(ctx, conn)
		require.NoError(t, err)

		record, err = table.FindByPK(ctx, conn, id)
		require.NoError(t, err)
		require.Equal(t, map[string]any{"id": int32(1), "name": "Bill", "age": int32(42)}, record.Attributes())
	})
}

func TestSelect(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		people, err := pgxrecord.Select(ctx, conn, `select n, 'John', 42 from generate_series(1,3) n`, nil, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 3)
		require.EqualValues(t, 1, people[0].ID)
		require.Equal(t, "John", people[0].Name)
		require.EqualValues(t, 42, people[0].Age)
		require.EqualValues(t, 2, people[1].ID)
		require.Equal(t, "John", people[1].Name)
		require.EqualValues(t, 42, people[1].Age)
		require.EqualValues(t, 3, people[2].ID)
		require.Equal(t, "John", people[2].Name)
		require.EqualValues(t, 42, people[2].Age)
	})
}

func TestSelectNoRows(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		people, err := pgxrecord.Select(ctx, conn, `select 1, 'John', 42 where false`, nil, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 0)
	})
}

func TestSelectRow(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		person, err := pgxrecord.SelectRow(ctx, conn, `select 1, 'John', 42`, nil, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.EqualValues(t, 1, person.ID)
		require.Equal(t, "John", person.Name)
		require.EqualValues(t, 42, person.Age)
	})
}

func TestSelectRowNoRows(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		person, err := pgxrecord.SelectRow(ctx, conn, `select 1, 'John', 42 where false`, nil, pgx.RowToAddrOfStructByPos[Person])
		require.ErrorIs(t, err, pgx.ErrNoRows)
		require.Nil(t, person)
	})
}

func TestInsert(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		people, err := pgxrecord.Insert(ctx, conn, pgx.Identifier{"t"}, []map[string]any{{"name": "John", "age": 42}, {"name": "Jane", "age": 40}}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 2)
		require.EqualValues(t, 1, people[0].ID)
		require.Equal(t, "John", people[0].Name)
		require.EqualValues(t, 42, people[0].Age)
		require.EqualValues(t, 2, people[1].ID)
		require.Equal(t, "Jane", people[1].Name)
		require.EqualValues(t, 40, people[1].Age)

		people, err = pgxrecord.Select(ctx, conn, `select * from t order by id`, nil, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.EqualValues(t, 1, people[0].ID)
		require.Equal(t, "John", people[0].Name)
		require.EqualValues(t, 42, people[0].Age)
		require.EqualValues(t, 2, people[1].ID)
		require.Equal(t, "Jane", people[1].Name)
		require.EqualValues(t, 40, people[1].Age)
	})
}

func TestInsertSQL(t *testing.T) {
	t.Parallel()

	tests := []struct {
		testName  string
		tableName pgx.Identifier
		rows      []map[string]any
		sql       string
		args      []any
	}{
		{
			testName:  "Single row",
			tableName: pgx.Identifier{"people"},
			rows:      []map[string]any{{"name": "Adam", "sex": "male"}},
			sql:       `insert into people (name, sex) values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Multiple rows",
			tableName: pgx.Identifier{"people"},
			rows:      []map[string]any{{"name": "Adam", "sex": "male"}, {"name": "Eve", "sex": "female"}, {"name": "Cain", "sex": "male"}, {"name": "Abel", "sex": "male"}},
			sql:       `insert into people (name, sex) values ($1, $2), ($3, $4), ($5, $6), ($7, $8) returning *`,
			args:      []any{"Adam", "male", "Eve", "female", "Cain", "male", "Abel", "male"},
		},
		{
			testName:  "Schema qualified table",
			tableName: pgx.Identifier{"public", "people"},
			rows:      []map[string]any{{"name": "Adam", "sex": "male"}},
			sql:       `insert into "public"."people" (name, sex) values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Table with special characters",
			tableName: pgx.Identifier{"Bible Characters"},
			rows:      []map[string]any{{"name": "Adam", "sex": "male"}},
			sql:       `insert into "Bible Characters" (name, sex) values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Column with special characters",
			tableName: pgx.Identifier{"people"},
			rows:      []map[string]any{{"Complete Name": "Adam", "sex": "male"}},
			sql:       `insert into people ("Complete Name", sex) values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			sql, args := pgxrecord.Private_insertSQL(tt.tableName, tt.rows, "*")
			assert.Equal(t, tt.sql, sql)
			assert.Equal(t, tt.args, args)
		})
	}
}

func TestInsertRow(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		person, err := pgxrecord.InsertRow(ctx, conn, pgx.Identifier{"t"}, map[string]any{"name": "John", "age": 42}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.EqualValues(t, 1, person.ID)
		require.Equal(t, "John", person.Name)
		require.EqualValues(t, 42, person.Age)

		person, err = pgxrecord.SelectRow(ctx, conn, `select * from t where id = $1`, []any{person.ID}, pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.EqualValues(t, 1, person.ID)
		require.Equal(t, "John", person.Name)
		require.EqualValues(t, 42, person.Age)
	})
}

func TestInsertRowSQL(t *testing.T) {
	t.Parallel()

	tests := []struct {
		testName  string
		tableName pgx.Identifier
		values    map[string]any
		sql       string
		args      []any
	}{
		{
			testName:  "Normal",
			tableName: pgx.Identifier{"people"},
			values:    map[string]any{"name": "Adam", "sex": "male"},
			sql:       `insert into people (name, sex) values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Schema qualified table",
			tableName: pgx.Identifier{"public", "people"},
			values:    map[string]any{"name": "Adam", "sex": "male"},
			sql:       `insert into "public"."people" (name, sex) values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Table with special characters",
			tableName: pgx.Identifier{"Bible Characters"},
			values:    map[string]any{"name": "Adam", "sex": "male"},
			sql:       `insert into "Bible Characters" (name, sex) values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
		{
			testName:  "Column with special characters",
			tableName: pgx.Identifier{"people"},
			values:    map[string]any{"Complete Name": "Adam", "sex": "male"},
			sql:       `insert into people ("Complete Name", sex) values ($1, $2) returning *`,
			args:      []any{"Adam", "male"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			sql, args := pgxrecord.Private_insertRowSQL(tt.tableName, tt.values, "*")
			assert.Equal(t, tt.sql, sql)
			assert.Equal(t, tt.args, args)
		})
	}
}

func TestSanitizeIdentifier(t *testing.T) {
	t.Parallel()

	tests := []struct {
		testName string
		arg      string
		result   string
	}{
		{
			testName: "No quoting needed",
			arg:      `foo_bar_123`,
			result:   `foo_bar_123`,
		},
		{
			testName: "Capital letter is quoted",
			arg:      `Foo`,
			result:   `"Foo"`,
		},
		{
			testName: "Space is quoted",
			arg:      `foo bar`,
			result:   `"foo bar"`,
		},
		{
			testName: "Special character is quoted",
			arg:      `foo*`,
			result:   `"foo*"`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			result := pgxrecord.Private_sanitizeIdentifier(tt.arg)
			assert.Equal(t, tt.result, result)
		})
	}
}

func TestExecRow(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		people, err := pgxrecord.Insert(ctx, conn, pgx.Identifier{"t"}, []map[string]any{{"name": "John", "age": 42}, {"name": "Jane", "age": 40}}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 2)
		require.EqualValues(t, 1, people[0].ID)
		require.EqualValues(t, 2, people[1].ID)

		ct, err := pgxrecord.ExecRow(ctx, conn, "update t set name = 'Bill' where id = $1", -1)
		require.ErrorIs(t, err, pgx.ErrNoRows)
		require.Equal(t, "UPDATE 0", ct.String())

		ct, err = pgxrecord.ExecRow(ctx, conn, "update t set name = 'Bill'")
		require.ErrorContains(t, err, "too many rows")
		require.Equal(t, "UPDATE 2", ct.String())
	})
}

func TestUpdateSQL(t *testing.T) {
	t.Parallel()

	tests := []struct {
		testName    string
		tableName   pgx.Identifier
		setValues   map[string]any
		whereValues map[string]any
		sql         string
		args        []any
	}{
		{
			testName:  "Update all rows",
			tableName: pgx.Identifier{"products"},
			setValues: map[string]any{"color": "green"},
			sql:       `update products set color = $1 returning *`,
			args:      []any{"green"},
		},
		{
			testName:  "Update multiple columns",
			tableName: pgx.Identifier{"products"},
			setValues: map[string]any{"color": "green", "size": "large"},
			sql:       `update products set color = $1, size = $2 returning *`,
			args:      []any{"green", "large"},
		},
		{
			testName:  "Schema qualified table",
			tableName: pgx.Identifier{"store", "products"},
			setValues: map[string]any{"color": "green"},
			sql:       `update "store"."products" set color = $1 returning *`,
			args:      []any{"green"},
		},
		{
			testName:  "Table with special characters",
			tableName: pgx.Identifier{"for sale products"},
			setValues: map[string]any{"color": "green"},
			sql:       `update "for sale products" set color = $1 returning *`,
			args:      []any{"green"},
		},
		{
			testName:  "Column with special characters",
			tableName: pgx.Identifier{"products"},
			setValues: map[string]any{"color": "green", "American size": "large"},
			sql:       `update products set "American size" = $1, color = $2 returning *`,
			args:      []any{"large", "green"},
		},
		{
			testName:    "Update some rows",
			tableName:   pgx.Identifier{"products"},
			setValues:   map[string]any{"color": "green"},
			whereValues: map[string]any{"color": "red"},
			sql:         `update products set color = $1 where color = $2 returning *`,
			args:        []any{"green", "red"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			sql, args := pgxrecord.Private_updateSQL(tt.tableName, tt.setValues, tt.whereValues, "*")
			assert.Equal(t, tt.sql, sql)
			assert.Equal(t, tt.args, args)
		})
	}
}

func TestUpdate(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		people, err := pgxrecord.Update(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 42}, nil, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 0)

		people, err = pgxrecord.Insert(ctx, conn, pgx.Identifier{"t"}, []map[string]any{{"name": "John", "age": 42}, {"name": "Jane", "age": 40}}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 2)

		people, err = pgxrecord.Update(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 70}, map[string]any{"name": "John"}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 1)
		require.EqualValues(t, 1, people[0].ID)
		require.Equal(t, "John", people[0].Name)
		require.EqualValues(t, 70, people[0].Age)
	})
}

func TestUpdateRow(t *testing.T) {
	t.Parallel()

	defaultConnTestRunner.RunTest(context.Background(), t, func(ctx context.Context, t testing.TB, conn *pgx.Conn) {
		_, err := conn.Exec(ctx, `create temporary table t (
	id int primary key generated by default as identity,
	name text not null,
	age int
)`)
		require.NoError(t, err)

		type Person struct {
			ID   int32
			Name string
			Age  int32
		}

		person, err := pgxrecord.UpdateRow(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 42}, nil, "*", pgx.RowToAddrOfStructByPos[Person])
		require.ErrorIs(t, err, pgx.ErrNoRows)
		require.Nil(t, person)

		people, err := pgxrecord.Insert(ctx, conn, pgx.Identifier{"t"}, []map[string]any{{"name": "John", "age": 42}, {"name": "Jane", "age": 40}}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.Len(t, people, 2)

		person, err = pgxrecord.UpdateRow(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 70}, map[string]any{"name": "John"}, "*", pgx.RowToAddrOfStructByPos[Person])
		require.NoError(t, err)
		require.NotNil(t, person)
		require.EqualValues(t, 1, person.ID)
		require.Equal(t, "John", person.Name)
		require.EqualValues(t, 70, person.Age)

		person, err = pgxrecord.UpdateRow(ctx, conn, pgx.Identifier{"t"}, map[string]any{"age": 70}, nil, "*", pgx.RowToAddrOfStructByPos[Person])
		require.ErrorContains(t, err, "too many rows")
	})
}
